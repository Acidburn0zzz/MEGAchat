#ifndef RETRYHANDLER_H
#define RETRYHANDLER_H

#include <promise.h>
#include <base/gcm.h>
#include <karereCommon.h>

#define RETRY_DEBUG_LOGGING 1

#ifdef RETRY_DEBUG_LOGGING
    #define RETRY_LOG(fmtString,...) KR_LOG_DEBUG("Retry: " fmtString, ##__VA_ARGS__)
#else
    #define RETRY_LOG(fmtString,...)
#endif

namespace mega
{
/** @brief
 * This is a simple class that retries a promise-returning function call, until the
 * returned promise is resolved (indiating that the operation succeeded), a maximum
 * number of retries has been reached and the retry handler gives up, or it has been
 * canceled by the user. The RetryHandler
 * has an output promise which is resolved when the operation succeeds, or rejected
 * if the retry handler gives up. That output promise has the same value type as the
 * promise returned by the function. When the function succeeds, the output promise is
 * resolved with the value returned by the function. When the retry handler gives up,
 * it rejects the output promise with the promise::Error object returned by the last
 * (failed) call of the function.
 */
template<class Func>
class RetryHandler
{
public:
    /** @brief
     * The value type of the promise returned by the operation and by the RetryHandler
     * itself
     */
    typedef typename decltype(std::declval<Func>().operator()())::Type RetType;
    enum { kPromiseType = 0x2e7294d1 };
    /**
     * The type of the promise errors generated by the RetryHandler. There is only one
     * situation when RetryHandler generates errors itself - when it is aborted.
     */
    typedef enum
    {
        kStateNotStarted = 0,
        kStateInProgress,
        kStateFinished
    } State;

    enum
    {
        kDefaultMaxAttemptCount = 0,
        kDefaultMaxSingleWaitTime = 60000
    };

protected:
    enum { kBitness = sizeof(size_t)*8-10 }; //maximum exponent of mInitialWaitTime that fits into a size_t
    State mState = kStateNotStarted;
    Func mFunc;
    size_t mCurrentAttemptNo = 0;
    size_t mMaxAttemptCount;
    size_t mMaxSingleWaitTime;
    promise::Promise<RetType> mPromise;
    unsigned long mWaitTimer = 0;
    unsigned short mInitialWaitTime;
    bool mAutoDestruct = false; //used when we use this object on the heap
public:
    /** Gets the output promise that is resolved. */
    promise::Promise<RetType>& getPromise() {return mPromise;}
    /** Tells the retry handler to delete itself after it has resolved the outupt promise.
     * This is convenient in a fire-and-forget scenario. Typically the user keeps
     * a copy of the output promise, obtained via getPromise(), which keeps the promise
     * alive even of the RetryHandler object is deleted. See the implementation of
     * the standalone function retry() for an example of that.
     * \warning This can be set only if the instance is allocated on the heap and not
     * on the stack
     */
    void setAutoDestroy() { mAutoDestruct = true; }
    /** @brief
     * The state of the retry handler - whether it has not yet been started, is in progress
     * or has finished and the output promise is resolved/rejected.
     */
    State state() const { return mState; }
    /**
     * @param func - The function that does the operation being retried.
     * This can be a lambda, function object or a C funtion pointer. The function
     * must return a promise and take no arguments.
     * @param maxSingleWaitTime - the maximum wait time between retries. The wait time
     * is calculated by multiplying \c backoffStart by 2^(current retry number). If it
     * exceeds maxSingleWaitTime, then it will be set to maxSingleWaitTime.
     * @param maxAttemptCount - the maximum number of retries before giving up. If it
     * is zero, then the retries will be repeated forever.
     * @param backoffStart - the delay before the second retry, which serves as a
     * starting point of the exponential formula. By default it is 1000ms, meaning that
     * the first wait will be 1s the next 2s, then 4s etc. If it is for example 120ms,
     * then the first wait will be 120ms, the next 240ms, then 480ms and so on.
     * This can be used for high frequency initial retrying.
     */
    RetryHandler(Func&& func, size_t maxSingleWaitTime=kDefaultMaxSingleWaitTime,
        size_t maxAttemptCount=kDefaultMaxAttemptCount, unsigned short backoffStart=1000)
    :mFunc(std::forward<Func>(func)), mMaxAttemptCount(maxAttemptCount),
      mMaxSingleWaitTime((maxSingleWaitTime>0) ? maxSingleWaitTime : ((size_t)-1)),
      mInitialWaitTime(backoffStart)
    {}
    ~RetryHandler()
    {
        RETRY_LOG("Deleting RetryHandler instance");
    }
    /** @brief Starts the retry attempts */
    void start()
    {
        if (mState != kStateNotStarted)
            throw std::runtime_error("RetryHandler: Already started or not reset after finished");
        nextTry();
    }
    /**
     * @brief abort
     * @return whether the abort was actually pefrormed or it
     * was not needed (i.e. not yet started or already finished). When the retries
     * are abouted, teh putput promise is immediately rejected with an error of type
     * RetryHandler::kPromiseType, code 1 and text "aborted".
     */
    bool abort()
    {
        if (mState != kStateInProgress)
            return false;

        if (mWaitTimer)
        {
            cancelTimeout(mWaitTimer);
            mWaitTimer = 0;
        }
        mPromise.reject(promise::Error("aborted", "1", kPromiseType));
        if (mAutoDestruct)
            delete this;
        return true;
    }
    /**
     * @brief reset
     * Re-initializes the retry handler after it has already finished. Then it can be
     * reused.
     * \warning After a reset(), the output promise is changed, because a promise cannot
     * be reused, so the user must use the new promise by calling getPromise()
     * after the reset().
     */
    void reset()
    {
        if (mState == kStateNotStarted)
            return;
        else if (mState == kStateInProgress)
            throw std::runtime_error("RetryHandler::reset: Can't reset while in progress");

        assert(mState == kStateFinished);
        asert(mWaitTimer == 0);

        mPromise = promise::Promise<RetType>();
        mCurrentAttemptNo = 0;
        mState = kStateNotStarted;
    }
    /**
     * @brief restart
     * Aborts, resets and starts the RetryHandler in one go.
     * @return Returns the new output promise. Even in case the retry handler
     * is already deleted when restart() returns (in case autoDestroy is set),
     * the promise is guaranteed to be valid.
     */
    promise::Promise<RetType> restart()
    {
        abort();
        reset();
        auto pms = getPromise();
        start();
        return pms;
    }
protected:
    size_t calcWaitTime()
    {
        if (mCurrentAttemptNo > kBitness)
            return mMaxSingleWaitTime;
        size_t t = (1 << (mCurrentAttemptNo-1)) * mInitialWaitTime;
        if (t <= mMaxSingleWaitTime)
            return t;
        else
            return mMaxSingleWaitTime;
    }
    void nextTry()
    {
        assert(mWaitTimer == 0);
        assert(!mPromise.done());

        mCurrentAttemptNo++;
        mFunc()
        .then([this](const RetType& ret)
        {
            mPromise.resolve(ret);
            mState = kStateFinished;
            if (mAutoDestruct)
                delete this;
            return ret;
        })
        .fail([this](const promise::Error& err)
        {
            if (mMaxAttemptCount && (mCurrentAttemptNo >= mMaxAttemptCount)) //give up
            {
                mPromise.reject(err);
                mState = kStateFinished;
                if (mAutoDestruct)
                    delete this;
                return err;
            }
            size_t waitTime = calcWaitTime();
            RETRY_LOG("Attempt %zu failed, will retry in %zu ms", mCurrentAttemptNo, waitTime);
            mWaitTimer = setTimeout([this]()
            {
                mWaitTimer = 0;
                nextTry();
            }, waitTime);
            return err;
        });
    }
};

/**
 * Convenience function to retry a lambda call returning a promise.
 * Internally it instantiates a RetryHandler instance and manages its lifetime
 * (by setting autoDestroy() and making the instance destroy itself after finishing).
 * The paramaters of this function are forwarder to the RetryHandler constructor.
 * @param The promise-returning (lambda) function to call. This function must take
 * no arguments.
 * @param maxSingleWaitTime - the maximum time in [ms] to wait between attempts. Default is 30 sec
 * @param maxRetries - the maximum number of attempts between giving up and rejecting
 * the returned promise. If it is zero, then it will retry forever. Default is 0
   @param backoffStart - the wait time after the first try, which is also the starting
   point of the backoff time algorithm: \c backoffStart * 2^(current_retry_number).
   See the constructor of RetryHandler for more details
 */
template <class Func>
static inline auto retry(Func&& func,
    size_t maxRetries = RetryHandler<Func>::kDefaultMaxAttemptCount,
    size_t maxSingleWaitTime = RetryHandler<Func>::kDefaultMaxSingleWaitTime,
    short backoffStart = 1000)
->decltype(func())
{
    auto self = new RetryHandler<Func>(
        std::forward<Func>(func), maxSingleWaitTime, maxRetries, backoffStart);
    auto promise = self->getPromise();
    self->setAutoDestroy();
    self->start(); //self may get destroyed synchronously here, but we have a reference to the promise
    return promise;
}

}

#endif // RETRYHANDLER_H

