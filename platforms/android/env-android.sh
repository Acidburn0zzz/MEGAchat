#!/bin/bash

# Source this file in the current shell to setup and android cross-compile build
# environment that supports CMake and autotools

#=== User-set variables

# Path to the toolchain generated by NDK's make-standalone-toolchain.sh script
export TOOLCHAIN_PATH=/home/loki/android-dev/toolchain

# The -march value that will be passed to the compiler
if [ -z "$TARGET_ARCH" ]; then
    export TARGET_ARCH=armv7-a@mthumb
fi

#=== End of user-set variables

function exportTool
{
   local path="$TOOLCHAIN_PATH/bin/arm-linux-androideabi-$2"
   export $1="$path"
   if [ ! -f "$path" ]; then
      echo -e "\033[1;31mTool $1 does not exist at path '$path'\033[1;0m"
      return
   fi
}

if [ -z "$TOOLCHAIN_PATH" ]; then
  echo "TOOLCHAIN_PATH must be set in the script, aborting"
  return 1
fi
if [ -z "$TARGET_ARCH" ]; then
  echo -e "\033[0;31mTARGET_ARCH not set, compiler will use default\033[1;0m"
fi

owndir=`echo "$(cd "$(dirname "$BASH_SOURCE")"; pwd)"`
toolchainFile="$owndir/toolchain.cmake"

if [ -z "$TOOLCHAIN_TYPE" ]; then
  if [ -f "$TOOLCHAIN_PATH/bin/clang" ]; then
     TOOLCHAIN_TYPE="clang"
  elif [ -f "TOOLCHAIN_PATH/bin/gcc" ]; then
     TOOLCHAIN_TYPE="gcc"
  else
     echo "Can't detect toolchain type: no compiler found at specificed TOOLCHAIN_PATH"
     return 1
  fi
  echo -e "\033[0;33mNo toolchain type specified, autodetected '$TOOLCHAIN_TYPE'\033[1;0m"
fi

if [[ "$TOOLCHAIN_TYPE" == "clang" ]]; then
  export ANDROID_CC_NAME=clang
  export ANDROID_CXX_NAME=clang++
else
  export ANDROID_CC_NAME=gcc
  export ANDROID_CXX_NAME=g++
fi
export TOOLCHAIN_BIN="$TOOLCHAIN_PATH/bin"
export SYSROOT="$TOOLCHAIN_PATH/sysroot"
export CFLAGS="--sysroot=$SYSROOT -march=$TARGET_ARCH"
export CXXFLAGS="--sysroot=$SYSROOT -march=$TARGET_ARCH"

#Seems the crosscompiler has the C++ system include paths broken, so we need to
#give them manually with -isystem. Note that this is automatically done by CMake, so
#has to be taken care of only with autotools configure scripts
#export CPPFLAGS="--sysroot=$SYSROOT -isystem /home/dbserver/android-ndk-r10d/platforms/android-14/arch-arm/usr/include -isystem /home/dbserver/android-ndk-r10d/sources/cxx-stl/gnu-libstdc++/4.8/include -isystem /home/dbserver/android-ndk-r10d/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -isystem /home/dbserver/android-ndk-r10d/sources/cxx-stl/gnu-libstdc++/4.8/include/backward"
#export LDFLAGS=--sysroot=$SYSROOT

exportTool CC "$ANDROID_CC_NAME"
exportTool CXX "$ANDROID_CXX_NAME"
exportTool CPP "cpp"
exportTool LD "ld"
exportTool AR "ar"
#exportTool LIBTOOL "libtool"
exportTool RANLIB "ranlib"
exportTool AS "as"
exportTool STRIP "strip"

# Convenience variables
# CMake command to configure strophe build to use the android toolchain:

# As the toolchain file is executed very early by cmake, some of the variables
# that we set in it aren't created in the cache yet. If we set them without
# the CACHE flag, they will be reset when the cache entry is created later.
# The symptoms for this  are that the first time the user cmake file is run,
# it doesn't see the variable as defined here, but if it is run a second time
# (i.e. after a modification), the variable may 'correct itself', as it
# already exists in the cache, so it's not re-created (and reset) anymore.
# So, we must create cache entries early here for all variables that normally
# are put in cache 

if [ ! -f "$toolchainFile" ]; then

echo -e "# This toolchain file is autogenerated by env-android.sh\n\
\n\
# CMAKE_SYSTEM_NAME is used only for filename stuff, android is not recognized,\n\
# so set it to Linux
set(CMAKE_SYSTEM_NAME Linux)\n\
set(ANDROID 1)\n\
set(TARGET_ARCH $TARGET_ARCH)\n\
set(CMAKE_C_COMPILER \"$CC\" CACHE PATH \"\")\n\
set(CMAKE_CXX_COMPILER \"$CXX\" CACHE PATH \"\")\n\
set(CMAKE_SYSROOT \"$SYSROOT\")\n\
set(CMAKE_FIND_ROOT_PATH \"$SYSROOT\")\n\
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\n\
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\n\
set(CMAKE_INSTALL_PREFIX \"$SYSROOT/usr\" CACHE PATH \"\")\n" > "$toolchainFile"
fi

# FIXME: Cmake picks the --sysroot flag from CFLAGS/CXXFLAGS, and also adds it
# via CMAKE_SYSROOT, resulting in the flag appearing twice

export CMAKE_XCOMPILE_ARGS="-DCMAKE_TOOLCHAIN_FILE=$toolchainFile"

# Typical configure command to build dependencies:
export CONFIGURE_XCOMPILE_ARGS="--host=arm-linux-gnueabi\
       \"--prefix=$SYSROOT/usr\" \"--with-sysroot=$SYSROOT\""

function xcmake
{
  eval cmake $CMAKE_XCOMPILE_ARGS $@
}

function xconfigure
{
  eval ./configure $CONFIGURE_XCOMPILE_ARGS $@
}

echo "============================================"
echo "Envirnoment set to use cross-compiler toolchain:"
echo "Toolchain path: $TOOLCHAIN_PATH"
echo "Toolchain type: $TOOLCHAIN_TYPE"
echo "Target cpuarch: $TARGET_ARCH"
echo "sysroot:        $SYSROOT"
echo "C Compiler:     $CC"
echo "C++ Compiler:   $CXX"
echo
echo -e "For autotools, you can use\n\
xconfigure [your-args]\n\
or\n\
\033[1;30meval\e[0m ./configure \$CONFIGURE_XCOMPILE_ARGS [your-args]\n\
This also sets up the install prefix to the SYSROOT/usr directory\n\
\n\
For CMake, you can use \n\
xcmake [your-args]\n\
or\n\
\033[1;30meval\e[0m cmake \$CMAKE_XCOMPILE_ARGS [your-args]\n\
This also sets up the CMake install prefix to the SYSROOT/usr directory\n\
\n\
After the autoconf/cmake configure step, you can do, as normal:\n\
make && make install"

